{"ast":null,"code":"import _objectSpread from\"C:/Users/MSI/Videos/Employee-Register-App/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import React,{createContext,useContext,useReducer,useEffect,useState}from'react';import{io}from'socket.io-client';import{notificationAPI}from'../services/api';import{useAuth}from'./AuthContext';import toast from'react-hot-toast';// Initial state\nimport{jsx as _jsx}from\"react/jsx-runtime\";const initialState={notifications:[],unreadCount:0,isLoading:false,error:null};// Action types\nconst NOTIFICATION_ACTIONS={FETCH_START:'FETCH_START',FETCH_SUCCESS:'FETCH_SUCCESS',FETCH_FAILURE:'FETCH_FAILURE',ADD_NOTIFICATION:'ADD_NOTIFICATION',MARK_AS_READ:'MARK_AS_READ',MARK_ALL_AS_READ:'MARK_ALL_AS_READ',DELETE_NOTIFICATION:'DELETE_NOTIFICATION',CLEAR_ERROR:'CLEAR_ERROR'};// Reducer function\nconst notificationReducer=(state,action)=>{switch(action.type){case NOTIFICATION_ACTIONS.FETCH_START:return _objectSpread(_objectSpread({},state),{},{isLoading:true,error:null});case NOTIFICATION_ACTIONS.FETCH_SUCCESS:const notifications=action.payload.notifications||[];const unreadCount=notifications.filter(n=>!n.isRead).length;return _objectSpread(_objectSpread({},state),{},{notifications,unreadCount,isLoading:false,error:null});case NOTIFICATION_ACTIONS.FETCH_FAILURE:return _objectSpread(_objectSpread({},state),{},{isLoading:false,error:action.payload});case NOTIFICATION_ACTIONS.ADD_NOTIFICATION:const newNotification=action.payload;const updatedNotifications=[newNotification,...state.notifications];const newUnreadCount=newNotification.isRead?state.unreadCount:state.unreadCount+1;return _objectSpread(_objectSpread({},state),{},{notifications:updatedNotifications,unreadCount:newUnreadCount});case NOTIFICATION_ACTIONS.MARK_AS_READ:const{notificationId}=action.payload;const markAsReadNotifications=state.notifications.map(notification=>notification._id===notificationId?_objectSpread(_objectSpread({},notification),{},{isRead:true,readAt:new Date()}):notification);const markAsReadUnreadCount=markAsReadNotifications.filter(n=>!n.isRead).length;return _objectSpread(_objectSpread({},state),{},{notifications:markAsReadNotifications,unreadCount:markAsReadUnreadCount});case NOTIFICATION_ACTIONS.MARK_ALL_AS_READ:const markAllAsReadNotifications=state.notifications.map(notification=>!notification.isRead?_objectSpread(_objectSpread({},notification),{},{isRead:true,readAt:new Date()}):notification);return _objectSpread(_objectSpread({},state),{},{notifications:markAllAsReadNotifications,unreadCount:0});case NOTIFICATION_ACTIONS.DELETE_NOTIFICATION:const{id:deleteId}=action.payload;const deleteNotifications=state.notifications.filter(notification=>notification._id!==deleteId);const deleteUnreadCount=deleteNotifications.filter(n=>!n.isRead).length;return _objectSpread(_objectSpread({},state),{},{notifications:deleteNotifications,unreadCount:deleteUnreadCount});case NOTIFICATION_ACTIONS.CLEAR_ERROR:return _objectSpread(_objectSpread({},state),{},{error:null});default:return state;}};// Create context\nconst NotificationContext=/*#__PURE__*/createContext();// Notification provider component\nexport const NotificationProvider=_ref=>{let{children}=_ref;const[state,dispatch]=useReducer(notificationReducer,initialState);const[socket,setSocket]=useState(null);const[isConnected,setIsConnected]=useState(false);const{user,isAuthenticated}=useAuth();// Initialize socket connection\nuseEffect(()=>{if(isAuthenticated&&user){const newSocket=io(process.env.REACT_APP_SERVER_URL||'http://localhost:5000',{auth:{token:localStorage.getItem('accessToken')}});newSocket.on('connect',()=>{console.log('Connected to notification server');setIsConnected(true);// Join user-specific room\nnewSocket.emit('join-user-room',user.id);// Join role-based room\nif(user.role){newSocket.emit('join-role-room',user.role);}});newSocket.on('disconnect',()=>{console.log('Disconnected from notification server');setIsConnected(false);});newSocket.on('notification',notification=>{// Add notification to state\ndispatch({type:NOTIFICATION_ACTIONS.ADD_NOTIFICATION,payload:notification});// Show toast notification\nconst toastConfig={duration:notification.priority==='urgent'?6000:4000,position:'top-right'};switch(notification.type){case'success':toast.success(notification.message,toastConfig);break;case'error':toast.error(notification.message,toastConfig);break;case'warning':toast(notification.message,_objectSpread(_objectSpread({},toastConfig),{},{icon:'⚠️'}));break;default:toast(notification.message,toastConfig);}});newSocket.on('error',error=>{console.error('Socket error:',error);});setSocket(newSocket);return()=>{newSocket.close();};}else{if(socket){socket.close();setSocket(null);setIsConnected(false);}}},[isAuthenticated,user]);// Fetch notifications on component mount and when user changes\nuseEffect(()=>{if(isAuthenticated&&user){fetchNotifications();}},[isAuthenticated,user]);// Fetch notifications from API\nconst fetchNotifications=async function(){let limit=arguments.length>0&&arguments[0]!==undefined?arguments[0]:50;try{dispatch({type:NOTIFICATION_ACTIONS.FETCH_START});const response=await notificationAPI.getAll({limit});if(response.success){dispatch({type:NOTIFICATION_ACTIONS.FETCH_SUCCESS,payload:{notifications:response.data.notifications}});}else{throw new Error(response.message||'Failed to fetch notifications');}}catch(error){var _error$response,_error$response$data;const errorMessage=((_error$response=error.response)===null||_error$response===void 0?void 0:(_error$response$data=_error$response.data)===null||_error$response$data===void 0?void 0:_error$response$data.message)||error.message||'Failed to fetch notifications';dispatch({type:NOTIFICATION_ACTIONS.FETCH_FAILURE,payload:errorMessage});}};// Fetch unread notifications\nconst fetchUnreadNotifications=async function(){let limit=arguments.length>0&&arguments[0]!==undefined?arguments[0]:20;try{const response=await notificationAPI.getUnread({limit});if(response.success){// Add unread notifications to the beginning of the list\nresponse.data.notifications.forEach(notification=>{dispatch({type:NOTIFICATION_ACTIONS.ADD_NOTIFICATION,payload:notification});});}}catch(error){console.error('Failed to fetch unread notifications:',error);}};// Mark notification as read\nconst markAsRead=async notificationId=>{try{const response=await notificationAPI.markAsRead(notificationId);if(response.success){dispatch({type:NOTIFICATION_ACTIONS.MARK_AS_READ,payload:{notificationId}});}}catch(error){console.error('Failed to mark notification as read:',error);}};// Mark all notifications as read\nconst markAllAsRead=async()=>{try{const response=await notificationAPI.markAllAsRead();if(response.success){dispatch({type:NOTIFICATION_ACTIONS.MARK_ALL_AS_READ});toast.success('All notifications marked as read');}}catch(error){console.error('Failed to mark all notifications as read:',error);toast.error('Failed to mark all notifications as read');}};// Delete notification\nconst deleteNotification=async notificationId=>{try{const response=await notificationAPI.delete(notificationId);if(response.success){dispatch({type:NOTIFICATION_ACTIONS.DELETE_NOTIFICATION,payload:{id:notificationId}});toast.success('Notification deleted');}}catch(error){console.error('Failed to delete notification:',error);toast.error('Failed to delete notification');}};// Create notification (admin only)\nconst createNotification=async notificationData=>{try{const response=await notificationAPI.create(notificationData);if(response.success){toast.success('Notification created successfully');return{success:true};}else{throw new Error(response.message||'Failed to create notification');}}catch(error){var _error$response2,_error$response2$data;const errorMessage=((_error$response2=error.response)===null||_error$response2===void 0?void 0:(_error$response2$data=_error$response2.data)===null||_error$response2$data===void 0?void 0:_error$response2$data.message)||error.message||'Failed to create notification';toast.error(errorMessage);return{success:false,error:errorMessage};}};// Clear error\nconst clearError=()=>{dispatch({type:NOTIFICATION_ACTIONS.CLEAR_ERROR});};// Refresh notifications\nconst refreshNotifications=()=>{fetchNotifications();};const value=_objectSpread(_objectSpread({},state),{},{isConnected,// Actions\nfetchNotifications,fetchUnreadNotifications,markAsRead,markAllAsRead,deleteNotification,createNotification,clearError,refreshNotifications});return/*#__PURE__*/_jsx(NotificationContext.Provider,{value:value,children:children});};// Custom hook to use notification context\nexport const useNotifications=()=>{const context=useContext(NotificationContext);if(!context){throw new Error('useNotifications must be used within a NotificationProvider');}return context;};export default NotificationContext;","map":{"version":3,"names":["React","createContext","useContext","useReducer","useEffect","useState","io","notificationAPI","useAuth","toast","jsx","_jsx","initialState","notifications","unreadCount","isLoading","error","NOTIFICATION_ACTIONS","FETCH_START","FETCH_SUCCESS","FETCH_FAILURE","ADD_NOTIFICATION","MARK_AS_READ","MARK_ALL_AS_READ","DELETE_NOTIFICATION","CLEAR_ERROR","notificationReducer","state","action","type","_objectSpread","payload","filter","n","isRead","length","newNotification","updatedNotifications","newUnreadCount","notificationId","markAsReadNotifications","map","notification","_id","readAt","Date","markAsReadUnreadCount","markAllAsReadNotifications","id","deleteId","deleteNotifications","deleteUnreadCount","NotificationContext","NotificationProvider","_ref","children","dispatch","socket","setSocket","isConnected","setIsConnected","user","isAuthenticated","newSocket","process","env","REACT_APP_SERVER_URL","auth","token","localStorage","getItem","on","console","log","emit","role","toastConfig","duration","priority","position","success","message","icon","close","fetchNotifications","limit","arguments","undefined","response","getAll","data","Error","_error$response","_error$response$data","errorMessage","fetchUnreadNotifications","getUnread","forEach","markAsRead","markAllAsRead","deleteNotification","delete","createNotification","notificationData","create","_error$response2","_error$response2$data","clearError","refreshNotifications","value","Provider","useNotifications","context"],"sources":["C:/Users/MSI/Videos/Employee-Register-App/frontend/src/contexts/NotificationContext.js"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect, useState } from 'react';\nimport { io } from 'socket.io-client';\nimport { notificationAPI } from '../services/api';\nimport { useAuth } from './AuthContext';\nimport toast from 'react-hot-toast';\n\n// Initial state\nconst initialState = {\n  notifications: [],\n  unreadCount: 0,\n  isLoading: false,\n  error: null,\n};\n\n// Action types\nconst NOTIFICATION_ACTIONS = {\n  FETCH_START: 'FETCH_START',\n  FETCH_SUCCESS: 'FETCH_SUCCESS',\n  FETCH_FAILURE: 'FETCH_FAILURE',\n  ADD_NOTIFICATION: 'ADD_NOTIFICATION',\n  MARK_AS_READ: 'MARK_AS_READ',\n  MARK_ALL_AS_READ: 'MARK_ALL_AS_READ',\n  DELETE_NOTIFICATION: 'DELETE_NOTIFICATION',\n  CLEAR_ERROR: 'CLEAR_ERROR',\n};\n\n// Reducer function\nconst notificationReducer = (state, action) => {\n  switch (action.type) {\n    case NOTIFICATION_ACTIONS.FETCH_START:\n      return {\n        ...state,\n        isLoading: true,\n        error: null,\n      };\n\n    case NOTIFICATION_ACTIONS.FETCH_SUCCESS:\n      const notifications = action.payload.notifications || [];\n      const unreadCount = notifications.filter(n => !n.isRead).length;\n      \n      return {\n        ...state,\n        notifications,\n        unreadCount,\n        isLoading: false,\n        error: null,\n      };\n\n    case NOTIFICATION_ACTIONS.FETCH_FAILURE:\n      return {\n        ...state,\n        isLoading: false,\n        error: action.payload,\n      };\n\n    case NOTIFICATION_ACTIONS.ADD_NOTIFICATION:\n      const newNotification = action.payload;\n      const updatedNotifications = [newNotification, ...state.notifications];\n      const newUnreadCount = newNotification.isRead ? state.unreadCount : state.unreadCount + 1;\n      \n      return {\n        ...state,\n        notifications: updatedNotifications,\n        unreadCount: newUnreadCount,\n      };\n\n    case NOTIFICATION_ACTIONS.MARK_AS_READ:\n      const { notificationId } = action.payload;\n      const markAsReadNotifications = state.notifications.map(notification =>\n        notification._id === notificationId\n          ? { ...notification, isRead: true, readAt: new Date() }\n          : notification\n      );\n      const markAsReadUnreadCount = markAsReadNotifications.filter(n => !n.isRead).length;\n      \n      return {\n        ...state,\n        notifications: markAsReadNotifications,\n        unreadCount: markAsReadUnreadCount,\n      };\n\n    case NOTIFICATION_ACTIONS.MARK_ALL_AS_READ:\n      const markAllAsReadNotifications = state.notifications.map(notification =>\n        !notification.isRead ? { ...notification, isRead: true, readAt: new Date() } : notification\n      );\n      \n      return {\n        ...state,\n        notifications: markAllAsReadNotifications,\n        unreadCount: 0,\n      };\n\n    case NOTIFICATION_ACTIONS.DELETE_NOTIFICATION:\n      const { id: deleteId } = action.payload;\n      const deleteNotifications = state.notifications.filter(\n        notification => notification._id !== deleteId\n      );\n      const deleteUnreadCount = deleteNotifications.filter(n => !n.isRead).length;\n      \n      return {\n        ...state,\n        notifications: deleteNotifications,\n        unreadCount: deleteUnreadCount,\n      };\n\n    case NOTIFICATION_ACTIONS.CLEAR_ERROR:\n      return {\n        ...state,\n        error: null,\n      };\n\n    default:\n      return state;\n  }\n};\n\n// Create context\nconst NotificationContext = createContext();\n\n// Notification provider component\nexport const NotificationProvider = ({ children }) => {\n  const [state, dispatch] = useReducer(notificationReducer, initialState);\n  const [socket, setSocket] = useState(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const { user, isAuthenticated } = useAuth();\n\n  // Initialize socket connection\n  useEffect(() => {\n    if (isAuthenticated && user) {\n      const newSocket = io(process.env.REACT_APP_SERVER_URL || 'http://localhost:5000', {\n        auth: {\n          token: localStorage.getItem('accessToken'),\n        },\n      });\n\n      newSocket.on('connect', () => {\n        console.log('Connected to notification server');\n        setIsConnected(true);\n        \n        // Join user-specific room\n        newSocket.emit('join-user-room', user.id);\n        \n        // Join role-based room\n        if (user.role) {\n          newSocket.emit('join-role-room', user.role);\n        }\n      });\n\n      newSocket.on('disconnect', () => {\n        console.log('Disconnected from notification server');\n        setIsConnected(false);\n      });\n\n      newSocket.on('notification', (notification) => {\n        // Add notification to state\n        dispatch({\n          type: NOTIFICATION_ACTIONS.ADD_NOTIFICATION,\n          payload: notification,\n        });\n\n        // Show toast notification\n        const toastConfig = {\n          duration: notification.priority === 'urgent' ? 6000 : 4000,\n          position: 'top-right',\n        };\n\n        switch (notification.type) {\n          case 'success':\n            toast.success(notification.message, toastConfig);\n            break;\n          case 'error':\n            toast.error(notification.message, toastConfig);\n            break;\n          case 'warning':\n            toast(notification.message, { ...toastConfig, icon: '⚠️' });\n            break;\n          default:\n            toast(notification.message, toastConfig);\n        }\n      });\n\n      newSocket.on('error', (error) => {\n        console.error('Socket error:', error);\n      });\n\n      setSocket(newSocket);\n\n      return () => {\n        newSocket.close();\n      };\n    } else {\n      if (socket) {\n        socket.close();\n        setSocket(null);\n        setIsConnected(false);\n      }\n    }\n  }, [isAuthenticated, user]);\n\n  // Fetch notifications on component mount and when user changes\n  useEffect(() => {\n    if (isAuthenticated && user) {\n      fetchNotifications();\n    }\n  }, [isAuthenticated, user]);\n\n  // Fetch notifications from API\n  const fetchNotifications = async (limit = 50) => {\n    try {\n      dispatch({ type: NOTIFICATION_ACTIONS.FETCH_START });\n\n      const response = await notificationAPI.getAll({ limit });\n      \n      if (response.success) {\n        dispatch({\n          type: NOTIFICATION_ACTIONS.FETCH_SUCCESS,\n          payload: {\n            notifications: response.data.notifications,\n          },\n        });\n      } else {\n        throw new Error(response.message || 'Failed to fetch notifications');\n      }\n    } catch (error) {\n      const errorMessage = error.response?.data?.message || error.message || 'Failed to fetch notifications';\n      \n      dispatch({\n        type: NOTIFICATION_ACTIONS.FETCH_FAILURE,\n        payload: errorMessage,\n      });\n    }\n  };\n\n  // Fetch unread notifications\n  const fetchUnreadNotifications = async (limit = 20) => {\n    try {\n      const response = await notificationAPI.getUnread({ limit });\n      \n      if (response.success) {\n        // Add unread notifications to the beginning of the list\n        response.data.notifications.forEach(notification => {\n          dispatch({\n            type: NOTIFICATION_ACTIONS.ADD_NOTIFICATION,\n            payload: notification,\n          });\n        });\n      }\n    } catch (error) {\n      console.error('Failed to fetch unread notifications:', error);\n    }\n  };\n\n  // Mark notification as read\n  const markAsRead = async (notificationId) => {\n    try {\n      const response = await notificationAPI.markAsRead(notificationId);\n      \n      if (response.success) {\n        dispatch({\n          type: NOTIFICATION_ACTIONS.MARK_AS_READ,\n          payload: { notificationId },\n        });\n      }\n    } catch (error) {\n      console.error('Failed to mark notification as read:', error);\n    }\n  };\n\n  // Mark all notifications as read\n  const markAllAsRead = async () => {\n    try {\n      const response = await notificationAPI.markAllAsRead();\n      \n      if (response.success) {\n        dispatch({ type: NOTIFICATION_ACTIONS.MARK_ALL_AS_READ });\n        toast.success('All notifications marked as read');\n      }\n    } catch (error) {\n      console.error('Failed to mark all notifications as read:', error);\n      toast.error('Failed to mark all notifications as read');\n    }\n  };\n\n  // Delete notification\n  const deleteNotification = async (notificationId) => {\n    try {\n      const response = await notificationAPI.delete(notificationId);\n      \n      if (response.success) {\n        dispatch({\n          type: NOTIFICATION_ACTIONS.DELETE_NOTIFICATION,\n          payload: { id: notificationId },\n        });\n        toast.success('Notification deleted');\n      }\n    } catch (error) {\n      console.error('Failed to delete notification:', error);\n      toast.error('Failed to delete notification');\n    }\n  };\n\n  // Create notification (admin only)\n  const createNotification = async (notificationData) => {\n    try {\n      const response = await notificationAPI.create(notificationData);\n      \n      if (response.success) {\n        toast.success('Notification created successfully');\n        return { success: true };\n      } else {\n        throw new Error(response.message || 'Failed to create notification');\n      }\n    } catch (error) {\n      const errorMessage = error.response?.data?.message || error.message || 'Failed to create notification';\n      toast.error(errorMessage);\n      return { success: false, error: errorMessage };\n    }\n  };\n\n  // Clear error\n  const clearError = () => {\n    dispatch({ type: NOTIFICATION_ACTIONS.CLEAR_ERROR });\n  };\n\n  // Refresh notifications\n  const refreshNotifications = () => {\n    fetchNotifications();\n  };\n\n  const value = {\n    // State\n    ...state,\n    isConnected,\n    \n    // Actions\n    fetchNotifications,\n    fetchUnreadNotifications,\n    markAsRead,\n    markAllAsRead,\n    deleteNotification,\n    createNotification,\n    clearError,\n    refreshNotifications,\n  };\n\n  return (\n    <NotificationContext.Provider value={value}>\n      {children}\n    </NotificationContext.Provider>\n  );\n};\n\n// Custom hook to use notification context\nexport const useNotifications = () => {\n  const context = useContext(NotificationContext);\n  \n  if (!context) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  \n  return context;\n};\n\nexport default NotificationContext;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}